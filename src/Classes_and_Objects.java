import java.util.ArrayList;
import java.util.List;

/*********** Урок 33: Введение в параметризацию. (Generics)  ************/

/*
Параметризация (Generics) в Java позволяет создавать классы, интерфейсы и методы,
которые могут работать с разными типами данных, сохраняя при этом безопасность типов.
Это важная часть языка, которая позволяет писать гибкий и повторно используемый код,
избегая ошибок приведения типов на этапе компиляции.

Generics добавляет возможность параметризации типов данных, что делает код более общим и безопасным.
Например, вы можете создать класс, который работает с любым типом данных, а не только с конкретным типом,
как Integer или String.
*/
public class Classes_and_Objects {
    public static void main(String[] args) {

        /*
            ___Причины необходимости Generics___
            Коллекции хранили объекты типа Object:
            Коллекции, такие как List, Set и Map, до появления Generics могли хранить объекты любых типов,
            потому что они были параметризованы на уровне базового типа — Object.
            Например, вот как выглядел код для создания списка:
        */

        List list = new ArrayList(); // Без Generics
        list.add("Hello");
        list.add(123);

        /*
            Здесь в список можно добавлять строки, числа и любые другие объекты,
            так как всё наследуется от Object. Но при извлечении данных из списка программа не знала заранее,
            что за тип данных был добавлен, поэтому разработчику приходилось явно приводить тип:
        */
        String str = (String) list.get(0);  // Явное приведение к String
        Integer num = (Integer) list.get(1);  // Явное приведение к Integer




        /*  ___Отсутствие гарантии типов на этапе компиляции___
            Без Generics ошибки с неверным приведением типов обнаруживались только во время выполнения программы,
            а не во время компиляции. Это увеличивало вероятность ошибок, особенно в больших проектах,
            где один и тот же контейнер мог использоваться для хранения разных типов данных.
            Если разработчик случайно приведёт элемент к неверному типу, программа завершится с исключением ClassCastException.
         */



        /*
            ___Как Generics изменили ситуацию___:
            Generics позволили избежать необходимости явного приведения типов, так как они позволяют
            параметризовать коллекции и другие классы. Теперь можно указать тип данных, который будет храниться
            в коллекции, и компилятор будет проверять типы на этапе компиляции, обеспечивая безопасность типов.
         */
        List<String> myList = new ArrayList<>();
        myList.add("Hello");
        String myStr = myList.get(0);  // Приведение больше не нужно



        // Теперь Box может работать с любым типом данных
        Box<String> stringBox = new Box<>();
        stringBox.set("Hello");

        Box<Integer> intBox = new Box<>();
        intBox.set(123);


    }

}

/*
    Гибкость Generics заключается в том, что они позволяют вам создавать универсальные классы, методы и интерфейсы,
    которые могут работать с разными типами данных, без необходимости дублировать код для каждого типа.
    Представьте, что вам нужно создать класс "коробка" (Box), которая может хранить разные типы объектов,
    например, строки, числа и т. д. Без Generics вам пришлось бы создавать отдельные классы для каждого типа:
 */
class StringBox {
    private String value;

    public void set(String value) {
        this.value = value;
    }

    public String get() {
        return value;
    }
}

class IntegerBox {
    private Integer value;

    public void set(Integer value) {
        this.value = value;
    }

    public Integer get() {
        return value;
    }
}

// Теперь посмотрим, как Generics добавляет гибкость:
class Box<T> {
    private T value;

    public void set(T value) {
        this.value = value;
    }

    public T get() {
        return value;
    }
}